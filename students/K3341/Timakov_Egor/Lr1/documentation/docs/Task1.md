В Данной лабораторной работе мы изучаем работу с Socket в языке Python. В Работе мы использовали как UDP-сокеты, так TCP-сокеты.
Также изучили и написали простые клиент-серверные приложения.

Разбор самих заданий:

## Первое задание
Реализовать клиентскую и серверную часть приложения. Клиент отправляет серверу сообщение «Hello, server», и оно должно отобразиться на стороне сервера. В ответ сервер отправляет клиенту сообщение «Hello, client», которое должно отобразиться у клиента.

---
Требования:
--
- Обязательно использовать библиотеку socket. 

- Реализовать с помощью протокола UDP.

---


## Второе задание
Реализовать клиентскую и серверную часть приложения. Клиент запрашивает выполнение математической операции, параметры которой вводятся с клавиатуры. Сервер обрабатывает данные и возвращает результат клиенту.

Варианты операций:

Теорема Пифагора.
Решение квадратного уравнения.
Поиск площади трапеции.
Поиск площади параллелограмма.
Порядок выбора варианта: Выбирается по порядковому номеру в журнале (пятый студент получает вариант 1 и т.д.).

---
Требования:
--
- Обязательно использовать библиотеку socket.

- Реализовать с помощью протокола TCP.

---

## Третье задание 

Реализовать серверную часть приложения. Клиент подключается к серверу, и в ответ получает HTTP-сообщение, содержащее HTML-страницу, которая сервер подгружает из файла index.html.

---
Требования
--

- Обязательно использовать библиотеку socket.

---

## Четвертое задание
Реализовать двухпользовательский или многопользовательский чат. Для максимального количества баллов реализуйте многопользовательский чат.

---
Требования:
--
- Обязательно использовать библиотеку socket.
- Для многопользовательского чата необходимо использовать библиотеку threading.
---
Реализация:
--
- Протокол TCP: 100% баллов.
- Протокол UDP: 80% баллов.
- Для UDP используйте threading для получения сообщений на клиенте.
- Для TCP запустите клиентские подключения и обработку сообщений от всех пользователей в потоках. Не забудьте сохранять пользователей, чтобы отправлять им сообщения.


## Пятое задание

Написать простой веб-сервер для обработки GET и POST HTTP-запросов с помощью библиотеки socket в Python.

---
Сервер должен:
--
- Принять и записать информацию о дисциплине и оценке по дисциплине.
- Отдать информацию обо всех оценках по дисциплинам в виде HTML-страницы.
---



## Выполнение первого пункта лабораторной работы



В данном задании надо написать простое клиент серверное приложение, где клиент отправляет: "hello server", а сервер отвечает: "Hello client"


В данной работе мы используем библиотеку socket. И реализовали связь между сервером и клиентом через протокол UDP.

В серверной части мы задаем настройки сервера, а именно адрес и порт. Затем мы мы создаем UDP-сокет
Строчки которая отвечает за создание сокета в серверной части приложения.
```
ServerSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

ServerSocket.bind((host, port)) 
```
Через аргумент ``socket.SOCK_DGRAM`` мы именно задаем UDP-сокет, а ``ServerSocet.bind`` - Задаем адрес и порт с которыми работает сервер.


В клиентской части приложения мы указываем адрес сервера и кодируем и отправляем сообщение через метод ``ClientSocket.sendto`` 
Далее ожидаем ответное сообщение через метод ``ClientSoceket.recvfrom`` 

## Выполнение второго пункта лабораторной работы

В данном задании реализуем второй вариант(Решение квадратного уравнения).

Для начала, как и в прошлом пункте выполнения лабораторной работы мы настраиваем параметры сервера т.е. адрес и порт.
Так как в данной работе нам необходимо использовать TCP-протокол, создание сокета будет отличатся от предыдущего пункта выполнения лабораторной работы
```
 with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind((HOST, PORT))
        s.listen()
        connection, address = s.accept()
```

Через аргумент ``socket.SOCK_STREAM`` указываем, что это TCP-сокет. ``s.listen`` - мы ожидаем запрос на TCP соединение, ``s.accept`` - мы отправляем ответ клиенту, что tcp соединение установлено.

В данном задании у нас имеется две функции одна решает квадратное уравнение, вторая запускает сервер и принимает данные.

Так как нам надо отправить не одну строку, а сразу несколько переменных, то для передачи данных мы используем json, поэтому на стороне сервера мы сначала принимаем данные в json,
декодируем их ``json.loads``, и передаем коэффициенты в функцию, которая решает квадратное уравнение. Результат который мы получили из функции, которая решает квадратное уравнение, мы тоже кодируем в json, через библиотеку json: ``json.dumps`` 

на стороне клиента Мы требуем ввод от пользователя, затем кодируем словарь в json ``json.dumps``, отправляем на сервер и ожидаем ответ от сервера в виде результата решения, затем декодируем json и выводим ответ пользователю
## Выполнение третьего пункта лабораторной работы

В данной работе нам надо написать простой http сервер, который будет отправлять html файл клиенту через браузер

При отправлении html файла в браузер мы будем использовать TCP соединение, так как нужно соединение, которое точно дойдет до клиента.

Для начала нам нужно загрузить содержимое html-файла, затем Мы формируем полный HTTP-ответ:
```
 http_response = (
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/html; charset=utf-8\r\n"
        f"Content-Length: {len(html_content.encode('utf-8'))}\r\n"
        "Connection: close\r\n"  
        "\r\n"  
        f"{html_content}"
    )
```
После этого мы создаем и настраиваем сокет:
``` 
 with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)


        server_socket.bind((HOST, PORT))

        server_socket.listen(1)
```

Эта строчка ``server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)`` Позволяет повторно использовать адресс сразу после закрытия.

Затем мы ожидаем http-запрос от клиента/браузера и отправляем http-ответ:
```
                conn, addr = server_socket.accept()
                with conn:
                    print(f"\nПолучено соединение от {addr}")

                    request = conn.recv(1024).decode('utf-8')
                    if not request:
                        continue
                    
                    conn.sendall(http_response.encode('utf-8'))
                    print(f"Ответ (файл {HTML_FILE}) отправлен.")

```

## Выполнение четвертого пункта лабораторной работы 

В данном задании нам необходимо реализовать многопользовательский чат

Для его рализации мы используем три функции:

- Первая функция занимается запуском сервера и запускает в отдельном потоке каждого клиента
- Вторая функция Занимается самим клиентом и получает сообщения от других клиентов
- Третья функция занимается отправкой сообщения клиентом и вызвавается из второй функции


Функция ``Start_server`` занимается создание TCP-сервера затем переходит в ожидание нового клиента.
```
        while True:
            client_socket, client_address = server.accept()

            with lock:
                clients.append(client_socket)

 
            thread = threading.Thread(target=handle_client, args=(client_socket, client_address))
            thread.start()
```
После того, как сервер принял соединения от нового клиента, он создает новый поток, где уже клиент может отправлять и получать сообщения от других клиентов.
После этого сервер ожидает новое подключение.


На клиентской части приложения мы подключаемся к серверу, отправляем свой никнейм серверу, и затем клиент может получать и отправлять сообщения другим клиентам
## Выполнение пятого пункта лабораторной работы

В данном задании нам, нужно записать информацию о дисциплинах и оценках по дисциплине, и выдавать результат виде html-странички

Для начала запускаем многопоточный TCP-сервер 
```
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    try:
        server_socket.bind((HOST, PORT))
        server_socket.listen(5)
```

Далее мы принимаем соединение, и отдаем запрос в отдельный поток

Функция, которая обрабатывает запрос клиента для начала проверяет не пустой ли запрос.
Затем мы Парсим первую строчку запроса для определения метода и пути
В случае если это get запрос то мы просто отправляем html-страницу
``` 
        if method == 'GET':
            if path == '/':
                html_body = get_html_page()
                response = build_response(200, "text/html", html_body)
            else:
                response = build_response(404, "text/html", "<h1>404 Not Found</h1>")

            conn.sendall(response)
```

В случае если это post запрос, то сервер парсит данные из тела запроса и обновляет словарь, и после редиректим пользователя.
``` 
        elif method == 'POST':
            
            if path == '/':
                # Находим тело POST-запроса (после пустой строки)
                body_start = request_data.find('\r\n\r\n') + 4
                post_body = request_data[body_start:].strip()

                params = parse_qs(post_body)

                discipline = params.get('discipline', [''])[0].strip()
                grade = params.get('grade', [''])[0].strip()

                if discipline and grade:
                    with data_lock:
                        grades_data[discipline] = grade
                    print(f"Сохранена новая оценка: {discipline} -> {grade}")

                    
                    response = build_response(303, "text/html", "")
                else:
                    response = build_response(200, "text/html", "<h1>Ошибка: Неполные данные</h1>")

                conn.sendall(response)

            else:
                response = build_response(404, "text/html", "<h1>404 Not Found</h1>")
                conn.sendall(response)
```

Также на сервере есть функция которая занимается генерированием html страницы. 







